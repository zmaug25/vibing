<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Editable Interactive Hotspot Tool</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    body {
      margin: 0;
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
      background-color: #111;
      color: #fff;
      overflow: hidden;
    }
    
    #background-container {
      position: relative;
      width: 100%;
      height: 100vh;
      overflow: hidden;
    }
    
    #background-container img, 
    #background-container video {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    
    .hotspot {
      position: absolute;
      width: 60px;
      height: 60px;
      border-radius: 50%;
      background-color: #0064ff;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: move;
      transition: all 0.3s ease;
      border: 4px solid rgba(255, 255, 255, 0.8);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
      user-select: none;
      z-index: 10;
    }
    
    .hotspot::before {
      content: '';
      position: absolute;
      width: 80px;
      height: 80px;
      border-radius: 50%;
      border: 2px solid rgba(255, 255, 255, 0.6);
      top: -12px;
      left: -12px;
      pointer-events: none;
    }
    
    .hotspot:hover {
      transform: scale(1.1);
      box-shadow: 0 6px 15px rgba(0, 0, 0, 0.6);
    }
    
    .hotspot.dragging {
      opacity: 0.8;
      transform: scale(1.2);
      z-index: 1000;
    }
    
    .hotspot svg {
      width: 30px;
      height: 30px;
      fill: white;
      pointer-events: none;
    }
    
    .hotspot::after {
      content: '';
      position: absolute;
      width: 100px;
      height: 100px;
      border-radius: 50%;
      border: 1px solid rgba(255, 255, 255, 0.3);
      top: -20px;
      left: -20px;
      animation: pulse 3s infinite;
      pointer-events: none;
    }
    
    @keyframes pulse {
      0% {
        transform: scale(1);
        opacity: 0.8;
      }
      50% {
        opacity: 0.4;
      }
      100% {
        transform: scale(1.2);
        opacity: 0;
      }
    }
    
    /* Popup */
    .popup {
      position: absolute;
      padding: 20px;
      background: linear-gradient(135deg, rgba(255, 0, 0, 0.95), rgba(200, 0, 0, 0.95));
      border-radius: 10px;
      display: none;
      z-index: 100;
      min-width: 250px;
      max-width: 400px;
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.6);
      border: 2px solid rgba(255, 255, 255, 0.3);
    }
    
    .popup-content {
      color: white;
    }
    
    .popup-content h3 {
      margin: 0 0 10px 0;
      font-size: 1.3em;
      text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.7);
    }
    
    .popup-content p {
      margin: 0 0 10px 0;
      line-height: 1.5;
      font-size: 0.9em;
    }
    
    .popup-content img, 
    .popup-content video {
      max-width: 100%;
      max-height: 200px;
      display: block;
      border-radius: 6px;
      margin: 8px 0;
    }
    
    .close-btn {
      position: absolute;
      top: 8px;
      right: 12px;
      font-size: 20px;
      color: white;
      cursor: pointer;
      background: rgba(0, 0, 0, 0.4);
      border-radius: 50%;
      width: 25px;
      height: 25px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.3s ease;
      z-index: 10;
    }
    
    .close-btn:hover {
      background: rgba(0, 0, 0, 0.7);
    }
    
    /* Editor Panel */
    .editor-panel {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.9);
      padding: 20px;
      border-radius: 10px;
      border: 2px solid rgba(255, 255, 255, 0.2);
      min-width: 300px;
      z-index: 1000;
      max-height: calc(100vh - 40px);
      overflow: auto;
    }
    
    .editor-panel h3 {
      margin: 0 0 15px 0;
      color: #fff;
      font-size: 1.2em;
    }
    
    .editor-group {
      margin-bottom: 15px;
    }
    
    .editor-group label {
      display: block;
      margin-bottom: 5px;
      color: #ccc;
      font-size: 0.9em;
    }
    
    .editor-group input,
    .editor-group select,
    .editor-group textarea {
      width: 100%;
      padding: 8px;
      border: 1px solid #444;
      border-radius: 5px;
      background: #222;
      color: #fff;
      font-size: 0.9em;
      box-sizing: border-box;
    }
    
    .editor-group input[type="color"] {
      width: 50px;
      height: 40px;
      padding: 0;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }
    
    .editor-group textarea {
      resize: vertical;
      min-height: 80px;
    }
    
    .editor-buttons {
      display: flex;
      gap: 10px;
      margin-top: 15px;
    }
    
    .editor-btn {
      padding: 8px 15px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 0.9em;
      transition: background 0.3s ease;
    }
    
    .btn-primary {
      background: rgba(255, 0, 0, 0.7);
      color: white;
    }
    
    .btn-primary:hover {
      background: rgba(255, 0, 0, 0.9);
    }
    
    .btn-secondary {
      background: rgba(100, 100, 100, 0.7);
      color: white;
    }
    
    .btn-secondary:hover {
      background: rgba(100, 100, 100, 0.9);
    }
    
    .btn-danger {
      background: rgba(255, 0, 0, 0.7);
      color: white;
    }
    
    .btn-danger:hover {
      background: rgba(255, 0, 0, 0.9);
    }
    
    /* Mode Toggle */
    .mode-toggle {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 1000;
    }
    
    .mode-btn {
      padding: 10px 20px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 1em;
      margin-right: 10px;
      transition: background 0.3s ease;
    }
    
    .mode-btn.active {
      background: rgba(255, 0, 0, 0.8);
      color: white;
    }
    
    .mode-btn:not(.active) {
      background: rgba(100, 100, 100, 0.7);
      color: white;
    }
    
    /* Hotspot colors are now set dynamically via JavaScript */
    
    /* File upload styling */
    .file-upload {
      position: relative;
      display: inline-block;
      cursor: pointer;
      width: 100%;
    }
    
    .file-upload input[type=file] {
      position: absolute;
      opacity: 0;
      width: 100%;
      height: 100%;
      cursor: pointer;
    }
    
    .file-upload-label {
      display: block;
      padding: 8px;
      border: 2px dashed #444;
      border-radius: 5px;
      text-align: center;
      color: #ccc;
      transition: border 0.3s ease;
    }
    
    .file-upload:hover .file-upload-label {
      border-color: #666;
    }
    
    /* Coordinates display */
    .coordinates { display: none; }
    
    /* Real-time update indicator */
    .real-time-indicator {
      position: fixed;
      top: 80px;
      left: 20px;
      background: rgba(0, 255, 0, 0.8);
      color: white;
      padding: 8px 12px;
      border-radius: 5px;
      font-size: 0.8em;
      z-index: 1000;
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    
    .real-time-indicator.show {
      opacity: 1;
    }
    
    /* Instruction Overlay */
    .instruction-overlay {
      position: fixed;
      bottom: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 20px;
      border-radius: 10px;
      border: 2px solid rgba(255, 255, 255, 0.2);
      max-width: 350px;
      z-index: 50;
      cursor: move;
      user-select: none;
    }
    .instruction-overlay .instruction-close {
      position: absolute;
      top: 6px;
      right: 8px;
      font-size: 16px;
      color: #ccc;
      cursor: pointer;
      background: rgba(0,0,0,0.4);
      border-radius: 50%;
      width: 22px;
      height: 22px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .instruction-overlay .instruction-close:hover { color: #fff; }
    
    .instruction-overlay h3 {
      margin: 0 0 10px 0;
      font-size: 1.2em;
      color: #fff;
    }
    
    .instruction-overlay p {
      margin: 0;
      line-height: 1.4;
      font-size: 0.9em;
      color: #ccc;
    }
    
    .instruction-overlay.editing {
      border-color: rgba(255, 255, 0, 0.6);
      box-shadow: 0 0 10px rgba(255, 255, 0, 0.3);
    }
    
    /* Background settings modal */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.6);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 2000;
    }
    
    .modal {
      background: #111;
      border: 1px solid #333;
      border-radius: 10px;
      width: 720px;
      max-width: calc(100% - 40px);
      color: #fff;
      box-shadow: 0 10px 30px rgba(0,0,0,0.7);
      max-height: 80vh;
      display: flex;
      flex-direction: column;
    }
    
    .modal-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 14px 16px;
      border-bottom: 1px solid #222;
    }
    
    .modal-title { font-size: 1.1em; margin: 0; }
    .modal-close { cursor: pointer; color: #aaa; font-size: 20px; }
    .modal-close:hover { color: #fff; }
    
    .modal-body { padding: 16px; overflow-y: auto; overflow-x: hidden; }
    .modal-footer { padding: 12px 16px; border-top: 1px solid #222; display: flex; gap: 10px; justify-content: space-between; align-items: center; }
    
    .bg-form-group { margin-bottom: 12px; }
    .bg-form-group label { display: block; margin-bottom: 6px; color: #ccc; font-size: 0.9em; }
    .bg-form-group input[type="text"] { width: 100%; padding: 8px; border: 1px solid #444; border-radius: 6px; background: #1a1a1a; color: #fff; }
    .bg-form-hint { font-size: 0.8em; color: #999; margin-top: 6px; }
    
    .bg-preview {
      border: 1px solid #333;
      border-radius: 8px;
      background: #0d0d0d;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      height: 180px;
      margin-top: 10px;
    }
    .bg-preview img { max-width: 100%; max-height: 100%; display: block; }
    
    .btn { padding: 8px 14px; border: none; border-radius: 6px; cursor: pointer; font-size: 0.9em; }
    .btn-ghost { background: rgba(100, 100, 100, 0.7); color: #fff; }
    .btn-ghost:hover { background: rgba(100, 100, 100, 0.9); }
    .btn-accent { background: rgba(0, 140, 255, 0.8); color: #fff; }
    .btn-accent:hover { background: rgba(0, 140, 255, 1); }
    
    /* Background badge */
    .bg-badge {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.6);
      color: #fff;
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 999px;
      padding: 6px 12px;
      font-size: 0.9em;
      z-index: 1000;
      max-width: 60vw;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    /* Profile badge */
    .profile-badge {
      position: fixed;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.6);
      color: #fff;
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 999px;
      padding: 6px 12px;
      font-size: 0.9em;
      z-index: 1000;
      max-width: 60vw;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
  </style>
</head>
<body>

<div id="background-container">
  <!-- Example: Replace this with your actual image -->
  <img src="https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=1200&h=800&fit=crop" alt="Mountain Landscape" onerror="this.style.display='none'; this.parentElement.style.background='linear-gradient(45deg, #1a1a2e, #16213e, #0f3460);'">
  
  <!-- Hotspots will be added here dynamically -->
</div>

<!-- Mode Toggle -->
<div class="mode-toggle" id="controlPanel" style="display:none;">
  <button class="mode-btn active" onclick="setMode('view')">View</button>
  <button class="mode-btn" onclick="setMode('edit')">Edit</button>
  <button class="mode-btn" onclick="addNewHotspot()" style="background: rgba(0, 255, 0, 0.7);">+ Hotspot</button>
  <button class="mode-btn" onclick="openBackgroundModal()" style="background: rgba(0, 140, 255, 0.7);">Background</button>
  <button class="mode-btn" onclick="openProfilesModal()" style="background: rgba(255, 165, 0, 0.8);">Profiles</button>
</div>

<!-- Editor Panel -->
<div class="editor-panel" id="editorPanel" style="display: none;">
  <h3>Hotspot Editor</h3>
  
  <div class="editor-group">
    <label>Position (X, Y):</label>
    <div style="display: flex; gap: 10px;">
      <input type="number" id="posX" placeholder="X" min="0" max="100" step="0.1">
      <input type="number" id="posY" placeholder="Y" min="0" max="100" step="0.1">
    </div>
  </div>
  
  <div class="editor-group">
    <label>Color:</label>
    <div style="display: flex; gap: 10px; align-items: center;">
      <input type="color" id="hotspotColor" value="#0064ff" style="width: 60px; height: 40px;">
      <input type="text" id="hotspotColorHex" placeholder="#0064ff" style="flex: 1;">
    </div>
  </div>
  
  <div class="editor-group">
    <label>Icon:</label>
    <select id="hotspotIcon">
      <option value="plus">Plus (+)</option>
      <option value="check">Check (✓)</option>
      <option value="star">Star (★)</option>
      <option value="info">Info (ℹ)</option>
      <option value="question">Question (?)</option>
      <option value="exclamation">Exclamation (!)</option>
      <option value="heart">Heart (♥)</option>
      <option value="circle">Circle (●)</option>
    </select>
  </div>
  
  <div class="editor-group">
    <label>Title:</label>
    <input type="text" id="hotspotTitle" placeholder="Enter title">
  </div>
  
  <div class="editor-group">
    <label>Description:</label>
    <textarea id="hotspotDescription" placeholder="Enter description"></textarea>
  </div>
  
  <div class="editor-group">
    <label>Upload Media:</label>
    <div class="file-upload">
      <input type="file" id="mediaUpload" accept="image/*,video/*">
      <label for="mediaUpload" class="file-upload-label">
        Click to upload image or video
      </label>
    </div>
    <div id="mediaPreview" style="margin-top: 10px;"></div>
  </div>
  
  <div class="editor-group" id="instructionEditor" style="display: none;">
    <label>Instruction Title:</label>
    <input type="text" id="instructionTitle" placeholder="Enter instruction title">
  </div>
  
  <div class="editor-group" id="instructionTextEditor" style="display: none;">
    <label>Instruction Text:</label>
    <textarea id="instructionText" placeholder="Enter instruction text"></textarea>
  </div>
  
  <div class="editor-group" id="instructionColorEditor" style="display: none;">
    <label>Background Color:</label>
    <div style="display: flex; gap: 10px; align-items: center;">
      <input type="color" id="instructionColor" value="#000000" style="width: 60px; height: 40px;">
      <input type="text" id="instructionColorHex" placeholder="#000000" style="flex: 1;">
    </div>
  </div>
  
  <div class="editor-group" id="instructionOpacityEditor" style="display: none;">
    <label>Opacity: <span id="opacityValue">80%</span></label>
    <input type="range" id="instructionOpacity" min="10" max="100" value="80" style="width: 100%;">
  </div>
  
  <div class="editor-group" id="instructionFontEditor" style="display: none;">
    <label>Font Family:</label>
    <select id="instructionFontFamily">
      <option value="Arial, sans-serif">Arial</option>
      <option value="'Times New Roman', serif">Times New Roman</option>
      <option value="'Courier New', monospace">Courier New</option>
      <option value="Georgia, serif">Georgia</option>
      <option value="Verdana, sans-serif">Verdana</option>
      <option value="'Trebuchet MS', sans-serif">Trebuchet MS</option>
      <option value="'Comic Sans MS', cursive">Comic Sans MS</option>
      <option value="Impact, sans-serif">Impact</option>
      <option value="'Lucida Console', monospace">Lucida Console</option>
    </select>
  </div>
  
  <div class="editor-group" id="instructionFontSizeEditor" style="display: none;">
    <label>Font Size: <span id="instructionFontSizeValue">16px</span></label>
    <input type="range" id="instructionFontSize" min="10" max="32" value="16" style="width: 100%;">
  </div>
  
  <div class="editor-group" id="popupFontEditor" style="display: none;">
    <label>Popup Font Family:</label>
    <select id="popupFontFamily">
      <option value="Arial, sans-serif">Arial</option>
      <option value="'Times New Roman', serif">Times New Roman</option>
      <option value="'Courier New', monospace">Courier New</option>
      <option value="Georgia, serif">Georgia</option>
      <option value="Verdana, sans-serif">Verdana</option>
      <option value="'Trebuchet MS', sans-serif">Trebuchet MS</option>
      <option value="'Comic Sans MS', cursive">Comic Sans MS</option>
      <option value="Impact, sans-serif">Impact</option>
      <option value="'Lucida Console', monospace">Lucida Console</option>
    </select>
  </div>
  
  <div class="editor-group" id="popupFontSizeEditor" style="display: none;">
    <label>Popup Font Size: <span id="popupFontSizeValue">16px</span></label>
    <input type="range" id="popupFontSize" min="10" max="32" value="16" style="width: 100%;">
  </div>
  
  <div class="editor-buttons">
    <button class="editor-btn btn-primary" onclick="saveHotspot()">Save</button>
    <button class="editor-btn btn-secondary" onclick="cancelEdit()">Close</button>
    <button class="editor-btn btn-danger" onclick="deleteHotspot()">Delete</button>
    <button class="editor-btn btn-secondary" onclick="editInstructions()">Edit Instructions</button>
  </div>
</div>

<!-- Coordinates Display -->
<div class="coordinates" id="coordinates">
  X: 0%, Y: 0%
</div>

<!-- Real-time Update Indicator -->
<div class="real-time-indicator" id="realTimeIndicator">
  ✓ Changes applied in real-time
</div>

<!-- Instruction Overlay -->
<div class="instruction-overlay" id="instructionOverlay">
  <span class="instruction-close" onclick="dismissInstructionOverlay(event)">×</span>
  <h3>Interactive Hotspot Demo</h3>
  <p>Click on the colored circles to explore different areas of this landscape. Each hotspot reveals information about specific features.</p>
</div>

<!-- Background badge -->
<div class="bg-badge" id="bgBadge" style="display: none; visibility: hidden;">Background: Default</div>

<!-- Profile badge -->
<div class="profile-badge" id="profileBadge" style="display: none; visibility: hidden;">Profile: Untitled Profile</div>

<!-- Background Settings Modal -->
<div class="modal-overlay" id="bgModal">
  <div class="modal" role="dialog" aria-modal="true" aria-labelledby="bgModalTitle">
    <div class="modal-header">
      <h4 class="modal-title" id="bgModalTitle">Background Settings</h4>
      <span class="modal-close" onclick="closeBackgroundModal()">×</span>
    </div>
    <div class="modal-body">
      <div class="bg-form-group">
        <label for="profileNameInput">Profile name</label>
        <input type="text" id="profileNameInput" placeholder="e.g., Trail Overview" />
      </div>
      <div class="bg-form-group">
        <label for="bgNameInput">Background name</label>
        <input type="text" id="bgNameInput" placeholder="e.g., Mountain Landscape" />
      </div>
      <div class="bg-form-group">
        <label for="bgUrlInput">Image URL</label>
        <input type="text" id="bgUrlInput" placeholder="https://example.com/image.jpg" />
        <div class="bg-form-hint">Use a publicly accessible URL for shareable links.</div>
      </div>
      <div class="bg-form-group">
        <label for="bgFileInput">Or upload an image</label>
        <input type="file" id="bgFileInput" accept="image/*" />
        <div class="bg-form-hint">Local uploads preview instantly but are not included in share links.</div>
      </div>
      <div class="bg-form-group">
        <label>Preview</label>
        <div class="bg-preview">
          <img id="bgPreview" alt="Background preview" />
        </div>
      </div>
    </div>
    <div class="modal-footer">
      <button class="btn btn-ghost" onclick="closeBackgroundModal()">Close</button>
      <div style="display:flex; gap:10px; align-items:center;">
        <span id="bgShareHint" class="bg-form-hint">Changes apply in real-time.</span>
        <button class="btn btn-accent" onclick="copySnapshotLink()" title="Copy link with background + hotspots">Copy snapshot link</button>
      </div>
    </div>
  </div>
  
  <!-- Profiles Manager Modal -->
  <div class="modal-overlay" id="profilesModal" style="display: none;">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="profilesModalTitle">
      <div class="modal-header">
        <h4 class="modal-title" id="profilesModalTitle">Profiles</h4>
        <span class="modal-close" onclick="closeProfilesModal()">×</span>
      </div>
      <div class="modal-body">
        <div class="bg-form-group">
          <label>Current profile</label>
          <div id="currentProfileInfo" style="font-size:0.9em; color:#ccc;">None loaded</div>
        </div>
        <div class="bg-form-group" style="display:flex; gap:10px; flex-wrap: wrap;">
          <button class="btn btn-accent" onclick="saveProfileChanges()" id="saveChangesBtn" disabled>Save changes</button>
          <input type="text" id="profilesNameInput" placeholder="New profile name" style="flex:1; min-width: 200px;" />
          <button class="btn btn-ghost" onclick="saveAsNewProfile()">Save as new</button>
        </div>
        <div class="bg-form-group">
          <label>Saved profiles</label>
          <div id="profilesList" class="bg-preview" style="height:auto; padding:10px; display:block; background:#121212; border:1px solid #333;">
            <!-- Profiles will be listed here -->
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-ghost" onclick="closeProfilesModal()">Close</button>
      </div>
    </div>
  </div>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
</div>

<script>
  let currentMode = 'view';
  let selectedHotspot = null;
  let isDragging = false;
  let dragOffset = { x: 0, y: 0 };
  let hotspotCounter = 1;
  let hotspots = [];
  let isAddingNewHotspot = false;
  let isEditingInstructions = false;
  let isDraggingInstructions = false;
  let currentBackground = { url: null, name: 'Default', isDataUrl: false };
  let currentProfile = { name: 'Untitled Profile' };
  let currentProfileId = null;
  const PROFILES_KEY = 'hotspotProfiles';
  
  // Initialize the tool
  document.addEventListener('DOMContentLoaded', function() {
    initializeBackgroundFromQuery();
    initializeSnapshotFromQuery();
    seedProfilesIfEmpty();
    initializeHotspots();
    setupEventListeners();
    updateProfileBadge();
    restoreInstructionOverlay();
    setupControlPanelHotkey();
  });
  
  function initializeHotspots() {
    // If hotspots were loaded from a snapshot, don't add samples
    if (hotspots && hotspots.length > 0) return;
    // Add some sample hotspots with hex colors and different icons
    addHotspot(25, 30, '#ff0000', 'Mountain Peak', 'This majestic peak stands at over 14,000 feet above sea level.', null, 'star');
    addHotspot(65, 25, '#00ff00', 'Alpine Forest', 'This dense forest is home to various wildlife including elk and deer.', null, 'info');
    addHotspot(75, 70, '#0064ff', 'Alpine Lake', 'This crystal-clear lake is fed by mountain snowmelt.', null, 'heart');
  }
  
  function setupEventListeners() {
    const container = document.getElementById('background-container');
    
    // Mouse events for dragging
    container.addEventListener('mousedown', handleMouseDown);
    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);
    
    // Touch events for mobile
    container.addEventListener('touchstart', handleTouchStart);
    document.addEventListener('touchmove', handleTouchMove);
    document.addEventListener('touchend', handleTouchEnd);
    
    // File upload preview
    document.getElementById('mediaUpload').addEventListener('change', handleFileUpload);
    
    // Background click for adding new hotspots
    container.addEventListener('click', handleBackgroundClick);
    
    // Background settings listeners
    const bgNameInput = document.getElementById('bgNameInput');
    const bgUrlInput = document.getElementById('bgUrlInput');
    const bgFileInput = document.getElementById('bgFileInput');
    const profilesNameInput = document.getElementById('profilesNameInput');
    const profileNameInput = document.getElementById('profileNameInput');
    if (profileNameInput) {
      profileNameInput.addEventListener('input', () => {
        currentProfile.name = profileNameInput.value || 'Untitled Profile';
        updateProfileBadge();
      });
    }
    
    if (bgNameInput) {
      bgNameInput.addEventListener('input', () => {
        currentBackground.name = bgNameInput.value || 'Untitled';
        updateBackgroundBadge();
      });
    }
    if (bgUrlInput) {
      bgUrlInput.addEventListener('input', () => {
        const url = bgUrlInput.value.trim();
        if (url.length === 0) return;
        setBackground(url, bgNameInput.value || currentBackground.name, false);
      });
    }
    if (bgFileInput) {
      bgFileInput.addEventListener('change', (e) => {
        const file = e.target.files && e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (ev) => {
          const dataUrl = ev.target.result;
          setBackground(dataUrl, bgNameInput.value || currentBackground.name, true);
          const hint = document.getElementById('bgShareHint');
          if (hint) hint.textContent = 'Using local image. Share link will not include this file.';
        };
        reader.readAsDataURL(file);
      });
    }
    if (profilesNameInput) {
      profilesNameInput.addEventListener('input', () => {
        // no-op, save on button
      });
    }
    
    // Real-time editor updates
    document.getElementById('posX').addEventListener('input', updateHotspotInRealTime);
    document.getElementById('posY').addEventListener('input', updateHotspotInRealTime);
    document.getElementById('hotspotColor').addEventListener('change', updateHotspotInRealTime);
    document.getElementById('hotspotColorHex').addEventListener('input', updateHotspotInRealTime);
    document.getElementById('hotspotIcon').addEventListener('change', updateHotspotInRealTime);
    document.getElementById('hotspotTitle').addEventListener('input', updateHotspotInRealTime);
    document.getElementById('hotspotDescription').addEventListener('input', updateHotspotInRealTime);
    
    // Instruction overlay events
    const instructionOverlay = document.getElementById('instructionOverlay');
    instructionOverlay.addEventListener('mousedown', handleInstructionMouseDown);
    instructionOverlay.addEventListener('click', handleInstructionClick);
    
    // Instruction editor events
    document.getElementById('instructionTitle').addEventListener('input', updateInstructionsInRealTime);
    document.getElementById('instructionText').addEventListener('input', updateInstructionsInRealTime);
    document.getElementById('instructionColor').addEventListener('change', updateInstructionsInRealTime);
    document.getElementById('instructionColorHex').addEventListener('input', updateInstructionColor);
    document.getElementById('instructionColorHex').addEventListener('blur', updateInstructionColor);
    document.getElementById('instructionColorHex').addEventListener('keypress', function(e) {
      if (e.key === 'Enter') {
        updateInstructionColor();
      }
    });
    document.getElementById('instructionOpacity').addEventListener('input', updateInstructionsInRealTime);
    document.getElementById('instructionFontFamily').addEventListener('change', updateInstructionsInRealTime);
    document.getElementById('instructionFontSize').addEventListener('input', updateInstructionsInRealTime);
    document.getElementById('popupFontFamily').addEventListener('change', updatePopupFonts);
    document.getElementById('popupFontSize').addEventListener('input', updatePopupFonts);
  }

  function setupControlPanelHotkey() {
    document.addEventListener('keydown', (e) => {
      if (e.key.toLowerCase() === 'c') {
        const panel = document.getElementById('controlPanel');
        if (panel) {
          const isHidden = panel.style.display === 'none' || panel.style.display === '';
          panel.style.display = isHidden ? 'block' : 'none';
        }
      }
    });
  }

  // ===================== Profiles Manager =====================
  function openProfilesModal() {
    const modal = document.getElementById('profilesModal');
    if (!modal) return;
    // Ensure the profiles modal is not inside a hidden parent (e.g., bgModal overlay)
    const bgOverlay = document.getElementById('bgModal');
    if (bgOverlay && bgOverlay.contains(modal)) {
      document.body.appendChild(modal);
    }
    updateCurrentProfileInfo();
    updateSaveChangesButton();
    const nameInput = document.getElementById('profilesNameInput');
    if (nameInput) nameInput.value = currentProfile.name || '';
    renderProfilesList();
    modal.style.display = 'flex';
  }
  
  function closeProfilesModal() {
    const modal = document.getElementById('profilesModal');
    if (modal) modal.style.display = 'none';
  }
  
  function loadProfilesFromStorage() {
    try {
      const raw = localStorage.getItem(PROFILES_KEY);
      if (!raw) return [];
      const arr = JSON.parse(raw);
      return Array.isArray(arr) ? arr : [];
    } catch (_) {
      return [];
    }
  }
  
  function saveProfilesToStorage(profiles) {
    try {
      localStorage.setItem(PROFILES_KEY, JSON.stringify(profiles));
      return true;
    } catch (err) {
      return false;
    }
  }
  
  function generateId() {
    if (window.crypto && crypto.randomUUID) return crypto.randomUUID();
    return 'p_' + Date.now() + '_' + Math.random().toString(36).slice(2, 8);
  }
  
  function saveCurrentProfile() {
    const nameInput = document.getElementById('profilesNameInput');
    const name = (nameInput && nameInput.value.trim()) || currentProfile.name || 'Untitled Profile';
    const state = getCurrentState();
    state.profile = state.profile || {};
    state.profile.name = name;
    currentProfile.name = name;
    updateProfileBadge();
    
    const profiles = loadProfilesFromStorage();
    if (currentProfileId) {
      const idx = profiles.findIndex(p => p.id === currentProfileId);
      if (idx !== -1) {
        profiles[idx] = { ...profiles[idx], name, state };
      } else {
        const id = generateId();
        currentProfileId = id;
        profiles.push({ id, name, createdAt: new Date().toISOString(), state });
      }
    } else {
      const id = generateId();
      currentProfileId = id;
      profiles.push({ id, name, createdAt: new Date().toISOString(), state });
    }
    saveProfilesToStorage(profiles);
    renderProfilesList();
  }

  function updateCurrentProfileInfo() {
    const info = document.getElementById('currentProfileInfo');
    if (!info) return;
    if (currentProfileId) {
      info.textContent = `${currentProfile.name} (id: ${currentProfileId.slice(0, 8)}…)`;
    } else {
      info.textContent = 'None loaded';
    }
  }

  function updateSaveChangesButton() {
    const btn = document.getElementById('saveChangesBtn');
    if (!btn) return;
    btn.disabled = !currentProfileId;
  }

  function saveProfileChanges() {
    if (!currentProfileId) return;
    const profiles = loadProfilesFromStorage();
    const idx = profiles.findIndex(p => p.id === currentProfileId);
    if (idx === -1) return;
    const state = getCurrentState();
    const name = currentProfile.name || (state.profile && state.profile.name) || 'Untitled Profile';
    profiles[idx] = { ...profiles[idx], name, state };
    const ok = saveProfilesToStorage(profiles);
    renderProfilesList();
    if (ok) {
      showToast('Saved changes to profile');
    } else {
      showToast('Save failed. Data may be too large.', true);
    }
  }

  function saveAsNewProfile() {
    const nameInput = document.getElementById('profilesNameInput');
    const name = (nameInput && nameInput.value.trim()) || `${currentProfile.name} (copy)` || 'New Profile';
    const state = getCurrentState();
    state.profile = state.profile || {};
    state.profile.name = name;
    const profiles = loadProfilesFromStorage();
    const id = generateId();
    profiles.push({ id, name, createdAt: new Date().toISOString(), state });
    const ok = saveProfilesToStorage(profiles);
    renderProfilesList();
    if (ok) {
      showToast('Saved new profile');
    } else {
      showToast('Save failed. Data may be too large.', true);
    }
  }

  function showToast(message, isError = false) {
    const indicator = document.getElementById('realTimeIndicator');
    if (!indicator) return;
    indicator.textContent = message;
    indicator.style.background = isError ? 'rgba(255, 0, 0, 0.85)' : 'rgba(0, 180, 0, 0.85)';
    indicator.classList.add('show');
    setTimeout(() => {
      indicator.classList.remove('show');
      indicator.textContent = '✓ Changes applied in real-time';
      indicator.style.background = 'rgba(0, 255, 0, 0.8)';
    }, 1200);
  }
  
  function renderProfilesList() {
    const container = document.getElementById('profilesList');
    if (!container) return;
    const profiles = loadProfilesFromStorage();
    if (profiles.length === 0) {
      container.innerHTML = '<div style="color:#aaa; padding:8px;">No profiles saved yet.</div>';
      return;
    }
    container.innerHTML = '';
    profiles.forEach(p => {
      const row = document.createElement('div');
      row.style.display = 'flex';
      row.style.alignItems = 'center';
      row.style.justifyContent = 'space-between';
      row.style.padding = '6px 8px';
      row.style.borderBottom = '1px solid #1f1f1f';
      const left = document.createElement('div');
      left.innerHTML = `<div style="font-weight:600;">${escapeHtml(p.name)}</div><div style=\"font-size:12px; color:#888;\">${new Date(p.createdAt).toLocaleString()}</div>`;
      const right = document.createElement('div');
      right.style.display = 'flex';
      right.style.gap = '8px';
      const loadBtn = document.createElement('button');
      loadBtn.className = 'btn btn-accent';
      loadBtn.textContent = 'Load';
      loadBtn.onclick = () => loadProfile(p.id);
      const delBtn = document.createElement('button');
      delBtn.className = 'btn btn-ghost';
      delBtn.textContent = 'Delete';
      delBtn.onclick = () => deleteProfile(p.id);
      right.appendChild(loadBtn);
      right.appendChild(delBtn);
      row.appendChild(left);
      row.appendChild(right);
      container.appendChild(row);
    });
  }
  
  function loadProfile(id) {
    const profiles = loadProfilesFromStorage();
    const p = profiles.find(x => x.id === id);
    if (!p) return;
    applyState(p.state);
    currentProfile.name = p.name || (p.state && p.state.profile && p.state.profile.name) || 'Untitled Profile';
    currentProfileId = p.id;
    updateProfileBadge();
    closeProfilesModal();
  }
  
  function deleteProfile(id) {
    const profiles = loadProfilesFromStorage();
    const next = profiles.filter(x => x.id !== id);
    saveProfilesToStorage(next);
    renderProfilesList();
  }
  
  function escapeHtml(str) {
    return String(str)
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/\"/g, '&quot;')
      .replace(/'/g, '&#039;');
  }

  // Seed a couple of demo profiles if none exist yet
  function seedProfilesIfEmpty() {
    const existing = loadProfilesFromStorage();
    if (existing.length > 0) return;
    const demo1 = {
      id: generateId(),
      name: 'Healthcare: OR Demo',
      createdAt: new Date().toISOString(),
      state: {
        profile: { name: 'Healthcare: OR Demo' },
        bg: {
          url: 'https://images.unsplash.com/photo-1586773860418-d37222d8fce3?w=1600&h=900&fit=crop',
          name: 'Operating Room'
        },
        hotspots: [
          { x: 22, y: 35, color: '#ff3b30', title: 'Vitals Monitor', description: 'Patient vitals and telemetry.', mediaUrl: '', icon: 'info' },
          { x: 58, y: 62, color: '#34c759', title: 'Infusion Pump', description: 'Medication delivery system.', mediaUrl: '', icon: 'plus' }
        ]
      }
    };
    const demo2 = {
      id: generateId(),
      name: 'Healthcare: ICU Demo',
      createdAt: new Date().toISOString(),
      state: {
        profile: { name: 'Healthcare: ICU Demo' },
        bg: {
          url: 'https://images.unsplash.com/photo-1582719478250-c89cae4dc85b?w=1600&h=900&fit=crop',
          name: 'ICU Room'
        },
        hotspots: [
          { x: 30, y: 28, color: '#0064ff', title: 'Ventilator', description: 'Respiratory support equipment.', mediaUrl: '', icon: 'info' },
          { x: 72, y: 70, color: '#ffcc00', title: 'Nurse Station', description: 'Observation and notes.', mediaUrl: '', icon: 'star' }
        ]
      }
    };
    saveProfilesToStorage([demo1, demo2]);
  }

  // ===================== Background Settings =====================
  function openBackgroundModal() {
    const modal = document.getElementById('bgModal');
    if (!modal) return;
    const nameInput = document.getElementById('bgNameInput');
    const urlInput = document.getElementById('bgUrlInput');
    const preview = document.getElementById('bgPreview');
    const hint = document.getElementById('bgShareHint');
    const profileNameInput = document.getElementById('profileNameInput');
    if (nameInput) nameInput.value = currentBackground.name || '';
    if (urlInput) urlInput.value = currentBackground.isDataUrl ? '' : (currentBackground.url || '');
    if (profileNameInput) profileNameInput.value = currentProfile.name || '';
    if (preview) preview.src = currentBackground.url || '';
    if (hint) hint.textContent = currentBackground.isDataUrl ? 'Using local image. Share link will not include this file.' : 'Changes apply in real-time.';
    modal.style.display = 'flex';
  }
  
  function closeBackgroundModal() {
    const modal = document.getElementById('bgModal');
    if (modal) modal.style.display = 'none';
  }
  
  function initializeBackgroundFromQuery() {
    const params = new URLSearchParams(window.location.search);
    const bgUrl = params.get('bgUrl');
    const bgName = params.get('bgName');
    if (bgUrl) {
      setBackground(bgUrl, bgName || 'Shared Background', false);
    } else {
      // Initialize currentBackground from existing img element
      const img = document.querySelector('#background-container img');
      if (img && img.src) {
        currentBackground.url = img.src;
        currentBackground.name = 'Default';
        currentBackground.isDataUrl = img.src.startsWith('data:');
        updateBackgroundBadge();
      }
    }
  }
  
  function setBackground(url, name, isDataUrl) {
    const img = document.querySelector('#background-container img');
    if (img) {
      img.src = url;
      img.alt = name || 'Background';
    }
    const preview = document.getElementById('bgPreview');
    if (preview) preview.src = url;
    currentBackground = { url, name: name || 'Untitled', isDataUrl: !!isDataUrl };
    updateBackgroundBadge();
    // Mark as dirty for current profile: enable Save changes button if a profile is loaded
    updateSaveChangesButton();
  }
  
  function updateBackgroundBadge() {
    const badge = document.getElementById('bgBadge');
    if (!badge) return;
    // keep hidden to reduce UI noise
    badge.style.display = 'block';
    badge.style.visibility = 'hidden';
    badge.textContent = 'Background: ' + (currentBackground.name || 'Untitled');
  }
  
  function updateProfileBadge() {
    const badge = document.getElementById('profileBadge');
    if (!badge) return;
    // keep hidden to reduce UI noise
    badge.style.display = 'block';
    badge.style.visibility = 'hidden';
    badge.textContent = 'Profile: ' + (currentProfile.name || 'Untitled Profile');
  }
  
  // (Share link removed; snapshot link supersedes it)

  // ===================== Snapshot Sharing =====================
  function encodeState(stateObj) {
    try {
      const json = JSON.stringify(stateObj);
      const bytes = new TextEncoder().encode(json);
      let binary = '';
      bytes.forEach(b => binary += String.fromCharCode(b));
      const base64 = btoa(binary)
        .replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/g, '');
      return base64;
    } catch (e) {
      return '';
    }
  }
  
  function decodeState(str) {
    try {
      const base64 = str.replace(/-/g, '+').replace(/_/g, '/');
      const pad = base64.length % 4 === 0 ? '' : '='.repeat(4 - (base64.length % 4));
      const binary = atob(base64 + pad);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
      const json = new TextDecoder().decode(bytes);
      return JSON.parse(json);
    } catch (e) {
      return null;
    }
  }
  
  function getCurrentState() {
    const state = {
      profile: { name: currentProfile.name },
      bg: { url: currentBackground.url, name: currentBackground.name },
      hotspots: hotspots.map(h => ({
        x: h.x,
        y: h.y,
        color: h.color,
        title: h.title,
        description: h.description,
        mediaUrl: h.mediaUrl || '',
        icon: h.icon || 'plus'
      }))
    };
    return state;
  }
  
  function applyState(state) {
    if (!state) return;
    // Profile
    if (state.profile && state.profile.name) {
      currentProfile.name = state.profile.name;
      updateProfileBadge();
    }
    // Background
    if (state.bg && state.bg.url) {
      setBackground(state.bg.url, state.bg.name || 'Shared Background', false);
    }
    // Clear existing hotspots
    document.querySelectorAll('.hotspot').forEach(el => el.remove());
    document.querySelectorAll('.popup').forEach(el => el.remove());
    hotspots = [];
    hotspotCounter = 1;
    // Add hotspots
    if (Array.isArray(state.hotspots)) {
      state.hotspots.forEach(h => {
        addHotspot(Number(h.x) || 0, Number(h.y) || 0, h.color || '#0064ff', h.title || '', h.description || '', h.mediaUrl || '', h.icon || 'plus');
      });
    }
  }
  
  function initializeSnapshotFromQuery() {
    const params = new URLSearchParams(window.location.search);
    const stateParam = params.get('state');
    if (!stateParam) return;
    const state = decodeState(stateParam);
    if (state) {
      applyState(state);
    }
  }
  
  async function copySnapshotLink() {
    const hint = document.getElementById('bgShareHint');
    const state = getCurrentState();
    const encoded = encodeState(state);
    if (!encoded) {
      if (hint) hint.textContent = 'Could not encode snapshot.';
      return;
    }
    const params = new URLSearchParams(window.location.search);
    params.set('state', encoded);
    // Optionally remove bgUrl/bgName when snapshot is present to shorten
    params.delete('bgUrl');
    params.delete('bgName');
    const url = window.location.pathname + '?' + params.toString();
    try {
      await navigator.clipboard.writeText(url);
      if (hint) hint.textContent = 'Snapshot link copied!';
      setTimeout(() => { if (hint) hint.textContent = currentBackground.isDataUrl ? 'Using local image. Share link will not include this file.' : 'Changes apply in real-time.'; }, 2000);
    } catch (_) {
      if (hint) hint.textContent = 'Unable to copy. Manually copy from address bar.';
    }
  }
  
  function setMode(mode) {
    currentMode = mode;
    
    // Update mode buttons
    document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
    event.target.classList.add('active');
    
    // Show/hide editor panel
    const editorPanel = document.getElementById('editorPanel');
    if (mode === 'edit') {
      editorPanel.style.display = 'block';
    } else {
      editorPanel.style.display = 'none';
      cancelEdit();
    }
    
    // Update cursor style
    const hotspots = document.querySelectorAll('.hotspot');
    hotspots.forEach(hotspot => {
      hotspot.style.cursor = mode === 'edit' ? 'move' : 'pointer';
    });
    
    // Update instruction overlay cursor
    const instructionOverlay = document.getElementById('instructionOverlay');
    instructionOverlay.style.cursor = mode === 'edit' ? 'move' : 'default';
  }
  
  function addHotspot(x, y, color, title, description, mediaUrl = null, iconType = 'plus') {
    const container = document.getElementById('background-container');
    const hotspotId = `hotspot${hotspotCounter}`;
    
    // Convert color to hex if it's a color name
    let hexColor = color;
    if (color && !color.startsWith('#')) {
      hexColor = colorNameToHex(color);
    }
    
    const hotspot = document.createElement('div');
    hotspot.className = 'hotspot';
    hotspot.id = hotspotId;
    hotspot.style.left = `${x}%`;
    hotspot.style.top = `${y}%`;
    hotspot.style.backgroundColor = hexColor;
    hotspot.dataset.color = hexColor;
    hotspot.dataset.title = title;
    hotspot.dataset.description = description;
    hotspot.dataset.mediaUrl = mediaUrl || '';
    hotspot.dataset.icon = iconType;
    
    hotspot.innerHTML = `
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        ${getIconSvg(iconType)}
      </svg>
    `;
    
    // Create popup
    const popup = document.createElement('div');
    popup.className = 'popup';
    popup.id = `popup${hotspotCounter}`;
    
    let mediaContent = '';
    if (mediaUrl) {
      if (mediaUrl.match(/\.(jpg|jpeg|png|gif|webp)$/i)) {
        mediaContent = `<img src="${mediaUrl}" alt="${title}">`;
      } else if (mediaUrl.match(/\.(mp4|webm|ogg)$/i)) {
        mediaContent = `<video controls><source src="${mediaUrl}" type="video/mp4"></video>`;
      }
    }
    
    popup.innerHTML = `
      <span class="close-btn">&times;</span>
      <div class="popup-content">
        <h3>${title}</h3>
        <p>${description}</p>
        ${mediaContent}
      </div>
    `;
    
    container.appendChild(hotspot);
    container.appendChild(popup);
    
    // Add event listeners
    addHotspotEventListeners(hotspot, popup);
    
    // Store hotspot data
    hotspots.push({
      id: hotspotId,
      x: x,
      y: y,
      color: hexColor,
      title: title,
      description: description,
      mediaUrl: mediaUrl,
      icon: iconType
    });
    
    hotspotCounter++;
  }
  
  function addHotspotEventListeners(hotspot, popup) {
    // Click event for view mode
    hotspot.addEventListener('click', function(e) {
      if (currentMode === 'view') {
        showPopup(hotspot, popup);
      } else if (currentMode === 'edit') {
        editHotspot(hotspot);
      }
    });
    
    // Close popup event
    const closeBtn = popup.querySelector('.close-btn');
    closeBtn.addEventListener('click', function(e) {
      e.stopPropagation(); // Prevent event bubbling
      popup.style.display = 'none';
    });
  }
  
  function showPopup(hotspot, popup) {
    // Close any other open popups first
    document.querySelectorAll('.popup').forEach(otherPopup => {
      if (otherPopup !== popup) {
        otherPopup.style.display = 'none';
      }
    });
    
    const rect = hotspot.getBoundingClientRect();
    popup.style.top = `${rect.bottom + 10}px`;
    popup.style.left = `${rect.left}px`;
    
    const color = hotspot.dataset.color;
    popup.style.background = `linear-gradient(135deg, ${hexToRgba(color, 0.95)}, ${hexToRgba(color, 0.85)})`;
    
    popup.style.display = 'block';
  }
  
  function editHotspot(hotspot) {
    selectedHotspot = hotspot;
    
    // Fill editor with current values
    const x = parseFloat(hotspot.style.left);
    const y = parseFloat(hotspot.style.top);
    
    document.getElementById('posX').value = x;
    document.getElementById('posY').value = y;
    
    // Handle color (convert from old color names to hex if needed)
    const currentColor = hotspot.dataset.color;
    let hexColor = currentColor;
    
    if (currentColor && !currentColor.startsWith('#')) {
      // Convert old color names to hex
      hexColor = colorNameToHex(currentColor);
    }
    
    document.getElementById('hotspotColor').value = hexColor;
    document.getElementById('hotspotColorHex').value = hexColor;
    document.getElementById('hotspotIcon').value = hotspot.dataset.icon || 'plus';
    document.getElementById('hotspotTitle').value = hotspot.dataset.title;
    document.getElementById('hotspotDescription').value = hotspot.dataset.description;
    
    // Show media preview if exists
    const mediaPreview = document.getElementById('mediaPreview');
    if (hotspot.dataset.mediaUrl) {
      if (hotspot.dataset.mediaUrl.match(/\.(jpg|jpeg|png|gif|webp)$/i)) {
        mediaPreview.innerHTML = `<img src="${hotspot.dataset.mediaUrl}" style="max-width: 100px; max-height: 100px; border-radius: 5px;">`;
      } else if (hotspot.dataset.mediaUrl.match(/\.(mp4|webm|ogg)$/i)) {
        mediaPreview.innerHTML = `<video controls style="max-width: 100px; max-height: 100px; border-radius: 5px;"><source src="${hotspot.dataset.mediaUrl}"></video>`;
      }
    } else {
      mediaPreview.innerHTML = '';
    }
  }
  
  function updateHotspotInRealTime(e) {
    if (!selectedHotspot) return;
    
    const x = parseFloat(document.getElementById('posX').value) || 0;
    const y = parseFloat(document.getElementById('posY').value) || 0;
    const colorPicker = document.getElementById('hotspotColor');
    const colorHex = document.getElementById('hotspotColorHex');
    const iconType = document.getElementById('hotspotIcon').value;
    const title = document.getElementById('hotspotTitle').value;
    const description = document.getElementById('hotspotDescription').value;
    
    // Determine color source: if event came from color input or hex field, prioritize that
    let color = colorPicker.value;
    if (e && e.target && e.target.id === 'hotspotColorHex') {
      const hex = colorHex.value.trim();
      if (isValidHexColor(hex)) {
        color = hex;
        colorPicker.value = hex;
      }
    } else if (e && e.target && e.target.id === 'hotspotColor') {
      colorHex.value = colorPicker.value;
      color = colorPicker.value;
    } else {
      // No specific source: prefer valid hex, else picker
      const hex = colorHex.value.trim();
      color = isValidHexColor(hex) ? hex : colorPicker.value;
      colorHex.value = color;
      colorPicker.value = color;
    }
    
    // Update hotspot position and appearance
    selectedHotspot.style.left = `${x}%`;
    selectedHotspot.style.top = `${y}%`;
    selectedHotspot.style.backgroundColor = color;
    selectedHotspot.dataset.color = color;
    selectedHotspot.dataset.title = title;
    selectedHotspot.dataset.description = description;
    selectedHotspot.dataset.icon = iconType;
    
    // Update icon
    const svg = selectedHotspot.querySelector('svg');
    if (svg) {
      svg.innerHTML = getIconSvg(iconType);
    }
    
    // Update popup content
    const popupId = selectedHotspot.id.replace('hotspot', 'popup');
    const popup = document.getElementById(popupId);
    if (popup) {
      const popupContent = popup.querySelector('.popup-content');
      const mediaUrl = selectedHotspot.dataset.mediaUrl;
      
      let mediaContent = '';
      if (mediaUrl) {
        if (mediaUrl.match(/\.(jpg|jpeg|png|gif|webp)$/i) || mediaUrl.startsWith('data:image/')) {
          mediaContent = `<img src="${mediaUrl}" alt="${title}">`;
        } else if (mediaUrl.match(/\.(mp4|webm|ogg)$/i) || mediaUrl.startsWith('data:video/')) {
          mediaContent = `<video controls><source src="${mediaUrl}" type="video/mp4"></video>`;
        }
      }
      
      popupContent.innerHTML = `
        <h3>${title}</h3>
        <p>${description}</p>
        ${mediaContent}
      `;
      
      // Update popup background color
      popup.style.background = `linear-gradient(135deg, ${hexToRgba(color, 0.95)}, ${hexToRgba(color, 0.85)})`;
    }
    
    // Update stored data
    const hotspotData = hotspots.find(h => h.id === selectedHotspot.id);
    if (hotspotData) {
      hotspotData.x = x;
      hotspotData.y = y;
      hotspotData.color = color;
      hotspotData.title = title;
      hotspotData.description = description;
      hotspotData.icon = iconType;
    }
    
    // Update coordinates display
    document.getElementById('coordinates').textContent = `X: ${x.toFixed(1)}%, Y: ${y.toFixed(1)}%`;
    
    // Show real-time update indicator
    showRealTimeIndicator();
    updateSaveChangesButton();
  }
  
  function showRealTimeIndicator() {
    const indicator = document.getElementById('realTimeIndicator');
    indicator.classList.add('show');
    
    // Hide after 1 second
    setTimeout(() => {
      indicator.classList.remove('show');
    }, 1000);
  }
  
  function editInstructions() {
    isEditingInstructions = true;
    
    // Show instruction editor fields
    document.getElementById('instructionEditor').style.display = 'block';
    document.getElementById('instructionTextEditor').style.display = 'block';
    document.getElementById('instructionColorEditor').style.display = 'block';
    document.getElementById('instructionOpacityEditor').style.display = 'block';
    document.getElementById('instructionFontEditor').style.display = 'block';
    document.getElementById('instructionFontSizeEditor').style.display = 'block';
    document.getElementById('popupFontEditor').style.display = 'block';
    document.getElementById('popupFontSizeEditor').style.display = 'block';
    
    // Fill with current values
    const overlay = document.getElementById('instructionOverlay');
    const title = overlay.querySelector('h3').textContent;
    const text = overlay.querySelector('p').textContent;
    
    // Extract current color and opacity from computed styles
    const computedStyle = window.getComputedStyle(overlay);
    const backgroundColor = computedStyle.backgroundColor;
    const opacity = Math.round(parseFloat(computedStyle.opacity) * 100);
    const fontFamily = computedStyle.fontFamily;
    const fontSize = parseInt(computedStyle.fontSize);
    
    // Convert rgba to hex
    let hexColor = '#000000';
    if (backgroundColor && backgroundColor !== 'rgba(0, 0, 0, 0)') {
      const rgba = backgroundColor.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);
      if (rgba) {
        const r = parseInt(rgba[1]);
        const g = parseInt(rgba[2]);
        const b = parseInt(rgba[3]);
        hexColor = `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
      }
    }
    
    document.getElementById('instructionTitle').value = title;
    document.getElementById('instructionText').value = text;
    document.getElementById('instructionColor').value = hexColor;
    document.getElementById('instructionColorHex').value = hexColor;
    document.getElementById('instructionOpacity').value = opacity;
    document.getElementById('opacityValue').textContent = `${opacity}%`;
    document.getElementById('instructionFontFamily').value = fontFamily;
    document.getElementById('instructionFontSize').value = fontSize;
    document.getElementById('instructionFontSizeValue').textContent = `${fontSize}px`;
    
    // Set popup font defaults
    document.getElementById('popupFontFamily').value = 'Arial, sans-serif';
    document.getElementById('popupFontSize').value = 16;
    document.getElementById('popupFontSizeValue').textContent = '16px';
    
    // Highlight the overlay
    overlay.classList.add('editing');
  }
  
  function updateInstructionsInRealTime() {
    if (!isEditingInstructions) return;
    
    const title = document.getElementById('instructionTitle').value;
    const text = document.getElementById('instructionText').value;
    const opacity = document.getElementById('instructionOpacity').value;
    const fontFamily = document.getElementById('instructionFontFamily').value;
    const fontSize = document.getElementById('instructionFontSize').value;
    
    // Get current color from hex input or color picker
    const colorHex = document.getElementById('instructionColorHex');
    const colorPicker = document.getElementById('instructionColor');
    let color = colorHex.value.trim() || colorPicker.value;
    
    // Ensure color has # prefix
    if (color && !color.startsWith('#')) {
      color = '#' + color;
    }
    
    // Convert hex to rgba with opacity
    const rgbaColor = hexToRgba(color, opacity / 100);
    
    const overlay = document.getElementById('instructionOverlay');
    overlay.querySelector('h3').textContent = title;
    overlay.querySelector('p').textContent = text;
    overlay.style.backgroundColor = rgbaColor;
    overlay.style.fontFamily = fontFamily;
    overlay.style.fontSize = `${fontSize}px`;
    
    // Update opacity value display
    document.getElementById('opacityValue').textContent = `${opacity}%`;
    document.getElementById('instructionFontSizeValue').textContent = `${fontSize}px`;
  }
  
  function updateInstructionColor() {
    if (!isEditingInstructions) return;
    
    const colorHex = document.getElementById('instructionColorHex');
    const colorPicker = document.getElementById('instructionColor');
    let color = colorHex.value.trim();
    
    // If hex input is empty, use color picker
    if (!color) {
      color = colorPicker.value;
      colorHex.value = color;
      return;
    }
    
    // Ensure color has # prefix
    if (!color.startsWith('#')) {
      color = '#' + color;
      colorHex.value = color;
    }
    
    // Validate hex color
    if (isValidHexColor(color)) {
      // Update color picker to match
      colorPicker.value = color;
      // Update the overlay color
      updateInstructionsInRealTime();
    }
  }
  
  function updatePopupFonts() {
    const fontFamily = document.getElementById('popupFontFamily').value;
    const fontSize = document.getElementById('popupFontSize').value;
    
    // Update all popups
    document.querySelectorAll('.popup').forEach(popup => {
      popup.style.fontFamily = fontFamily;
      popup.style.fontSize = `${fontSize}px`;
    });
    
    // Update font size display
    document.getElementById('popupFontSizeValue').textContent = `${fontSize}px`;
  }
  
  function handleInstructionClick(e) {
    if (currentMode === 'edit' && !isDraggingInstructions) {
      editInstructions();
    }
  }
  
  function handleInstructionMouseDown(e) {
    if (currentMode !== 'edit') return;
    
    isDraggingInstructions = true;
    const overlay = document.getElementById('instructionOverlay');
    
    const rect = overlay.getBoundingClientRect();
    dragOffset.x = e.clientX - rect.left;
    dragOffset.y = e.clientY - rect.top;
    
    e.preventDefault();
  }
  
  function dismissInstructionOverlay(e) {
    e.stopPropagation();
    const overlay = document.getElementById('instructionOverlay');
    if (overlay) {
      overlay.style.display = 'none';
      try { localStorage.setItem('instructionOverlayDismissed', '1'); } catch (_) {}
    }
  }

  function restoreInstructionOverlay() {
    try {
      const dismissed = localStorage.getItem('instructionOverlayDismissed') === '1';
      const overlay = document.getElementById('instructionOverlay');
      if (overlay) overlay.style.display = dismissed ? 'none' : 'block';
    } catch (_) {}
  }


  
  function saveHotspot() {
    // This function is now mainly for UI feedback since changes happen in real-time
    if (!selectedHotspot) return;
    
    // Show a brief success message
    const saveBtn = document.querySelector('.btn-primary');
    const originalText = saveBtn.textContent;
    saveBtn.textContent = 'Saved!';
    saveBtn.style.background = 'rgba(0, 255, 0, 0.8)';
    
    setTimeout(() => {
      saveBtn.textContent = originalText;
      saveBtn.style.background = 'rgba(255, 0, 0, 0.7)';
    }, 1000);
    
    selectedHotspot = null;
  }
  
  function cancelEdit() {
    selectedHotspot = null;
    isEditingInstructions = false;
    
    // Hide instruction editor fields
    document.getElementById('instructionEditor').style.display = 'none';
    document.getElementById('instructionTextEditor').style.display = 'none';
    document.getElementById('instructionColorEditor').style.display = 'none';
    document.getElementById('instructionOpacityEditor').style.display = 'none';
    document.getElementById('instructionFontEditor').style.display = 'none';
    document.getElementById('instructionFontSizeEditor').style.display = 'none';
    document.getElementById('popupFontEditor').style.display = 'none';
    document.getElementById('popupFontSizeEditor').style.display = 'none';
    
    // Remove editing highlight
    document.getElementById('instructionOverlay').classList.remove('editing');
    
    document.getElementById('editorPanel').style.display = 'none';
  }
  
  function deleteHotspot() {
    if (!selectedHotspot) return;
    
    // Remove hotspot and popup
    const popupId = selectedHotspot.id.replace('hotspot', 'popup');
    const popup = document.getElementById(popupId);
    
    selectedHotspot.remove();
    if (popup) popup.remove();
    
    // Remove from stored data
    hotspots = hotspots.filter(h => h.id !== selectedHotspot.id);
    
    selectedHotspot = null;
    cancelEdit();
  }
  
  function handleFileUpload(event) {
    const file = event.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = function(e) {
      const mediaUrl = e.target.result;
      
      if (selectedHotspot) {
        selectedHotspot.dataset.mediaUrl = mediaUrl;
        
        // Update popup in real-time
        const popupId = selectedHotspot.id.replace('hotspot', 'popup');
        const popup = document.getElementById(popupId);
        if (popup) {
          const popupContent = popup.querySelector('.popup-content');
          const title = selectedHotspot.dataset.title;
          const description = selectedHotspot.dataset.description;
          
          let mediaContent = '';
          if (file.type.startsWith('image/')) {
            mediaContent = `<img src="${mediaUrl}" alt="${title}">`;
          } else if (file.type.startsWith('video/')) {
            mediaContent = `<video controls><source src="${mediaUrl}" type="${file.type}"></video>`;
          }
          
          popupContent.innerHTML = `
            <h3>${title}</h3>
            <p>${description}</p>
            ${mediaContent}
          `;
        }
        
        // Update stored data
        const hotspotData = hotspots.find(h => h.id === selectedHotspot.id);
        if (hotspotData) {
          hotspotData.mediaUrl = mediaUrl;
        }
      }
      
      // Show preview
      const mediaPreview = document.getElementById('mediaPreview');
      if (file.type.startsWith('image/')) {
        mediaPreview.innerHTML = `<img src="${mediaUrl}" style="max-width: 100px; max-height: 100px; border-radius: 5px;">`;
      } else if (file.type.startsWith('video/')) {
        mediaPreview.innerHTML = `<video controls style="max-width: 100px; max-height: 100px; border-radius: 5px;"><source src="${mediaUrl}" type="${file.type}"></video>`;
      }
    };
    
    reader.readAsDataURL(file);
  }
  
  function addNewHotspot() {
    isAddingNewHotspot = true;
    setMode('edit');
    
    // Show instructions
    const coordinates = document.getElementById('coordinates');
    coordinates.innerHTML = 'Click anywhere on the background to place a new hotspot';
    coordinates.style.background = 'rgba(0, 255, 0, 0.8)';
  }
  
  function handleBackgroundClick(e) {
    if (!isAddingNewHotspot || currentMode !== 'edit') return;
    
    const container = document.getElementById('background-container');
    const containerRect = container.getBoundingClientRect();
    
    // Calculate position as percentage
    const x = ((e.clientX - containerRect.left) / containerRect.width) * 100;
    const y = ((e.clientY - containerRect.top) / containerRect.height) * 100;
    
    // Create new hotspot
    addHotspot(x, y, '#0064ff', 'New Hotspot', 'Click to edit this hotspot description.', null, 'plus');
    
    // Reset adding mode
    isAddingNewHotspot = false;
    const coordinates = document.getElementById('coordinates');
    coordinates.innerHTML = `X: ${x.toFixed(1)}%, Y: ${y.toFixed(1)}%`;
    coordinates.style.background = 'rgba(0, 0, 0, 0.8)';
    
    // Select the new hotspot for editing
    const newHotspot = document.querySelector(`#hotspot${hotspotCounter - 1}`);
    if (newHotspot) {
      editHotspot(newHotspot);
    }
  }
  
  // Mouse event handlers for dragging
  function handleMouseDown(e) {
    if (currentMode !== 'edit') return;
    
    const hotspot = e.target.closest('.hotspot');
    if (!hotspot) return;
    
    isDragging = true;
    selectedHotspot = hotspot;
    hotspot.classList.add('dragging');
    
    const rect = hotspot.getBoundingClientRect();
    const containerRect = document.getElementById('background-container').getBoundingClientRect();
    
    dragOffset.x = e.clientX - rect.left;
    dragOffset.y = e.clientY - rect.top;
    
    e.preventDefault();
  }
  
  function handleMouseMove(e) {
    if (isDraggingInstructions) {
      const overlay = document.getElementById('instructionOverlay');
      const newX = e.clientX - dragOffset.x;
      const newY = e.clientY - dragOffset.y;
      
      overlay.style.left = `${newX}px`;
      overlay.style.top = `${newY}px`;
      return;
    }
    
    if (!isDragging || !selectedHotspot) return;
    
    const container = document.getElementById('background-container');
    const containerRect = container.getBoundingClientRect();
    
    const x = ((e.clientX - containerRect.left - dragOffset.x) / containerRect.width) * 100;
    const y = ((e.clientY - containerRect.top - dragOffset.y) / containerRect.height) * 100;
    
    // Constrain to container bounds
    const constrainedX = Math.max(0, Math.min(100, x));
    const constrainedY = Math.max(0, Math.min(100, y));
    
    selectedHotspot.style.left = `${constrainedX}%`;
    selectedHotspot.style.top = `${constrainedY}%`;
    
    // Update coordinates display
    document.getElementById('coordinates').textContent = `X: ${constrainedX.toFixed(1)}%, Y: ${constrainedY.toFixed(1)}%`;
    
    // Update editor values (this will trigger real-time updates)
    document.getElementById('posX').value = constrainedX.toFixed(1);
    document.getElementById('posY').value = constrainedY.toFixed(1);
    
    // Update stored data
    const hotspotData = hotspots.find(h => h.id === selectedHotspot.id);
    if (hotspotData) {
      hotspotData.x = constrainedX;
      hotspotData.y = constrainedY;
    }
  }
  
  function handleMouseUp() {
    if (isDraggingInstructions) {
      isDraggingInstructions = false;
      return;
    }
    
    if (isDragging && selectedHotspot) {
      selectedHotspot.classList.remove('dragging');
      
      // Update stored data
      const x = parseFloat(selectedHotspot.style.left);
      const y = parseFloat(selectedHotspot.style.top);
      const hotspotData = hotspots.find(h => h.id === selectedHotspot.id);
      if (hotspotData) {
        hotspotData.x = x;
        hotspotData.y = y;
      }
    }
    
    isDragging = false;
  }
  
  // Touch event handlers for mobile
  function handleTouchStart(e) {
    if (currentMode !== 'edit') return;
    
    const touch = e.touches[0];
    const hotspot = document.elementFromPoint(touch.clientX, touch.clientY).closest('.hotspot');
    if (!hotspot) return;
    
    isDragging = true;
    selectedHotspot = hotspot;
    hotspot.classList.add('dragging');
    
    const rect = hotspot.getBoundingClientRect();
    dragOffset.x = touch.clientX - rect.left;
    dragOffset.y = touch.clientY - rect.top;
    
    e.preventDefault();
  }
  
  function handleTouchMove(e) {
    if (!isDragging || !selectedHotspot) return;
    
    const touch = e.touches[0];
    const container = document.getElementById('background-container');
    const containerRect = container.getBoundingClientRect();
    
    const x = ((touch.clientX - containerRect.left - dragOffset.x) / containerRect.width) * 100;
    const y = ((touch.clientY - containerRect.top - dragOffset.y) / containerRect.height) * 100;
    
    const constrainedX = Math.max(0, Math.min(100, x));
    const constrainedY = Math.max(0, Math.min(100, y));
    
    selectedHotspot.style.left = `${constrainedX}%`;
    selectedHotspot.style.top = `${constrainedY}%`;
    
    document.getElementById('coordinates').textContent = `X: ${constrainedX.toFixed(1)}%, Y: ${constrainedY.toFixed(1)}%`;
    document.getElementById('posX').value = constrainedX.toFixed(1);
    document.getElementById('posY').value = constrainedY.toFixed(1);
    
    // Update stored data
    const hotspotData = hotspots.find(h => h.id === selectedHotspot.id);
    if (hotspotData) {
      hotspotData.x = constrainedX;
      hotspotData.y = constrainedY;
    }
    
    e.preventDefault();
  }
  
  function handleTouchEnd() {
    handleMouseUp();
  }
  
  // Helper function to validate hex color
  function isValidHexColor(color) {
    // Only validate complete 6-character hex codes
    return /^#[0-9A-F]{6}$/i.test(color);
  }
  
  // Helper function to convert hex to RGBA
  function hexToRgba(hex, alpha) {
    // Remove # if present
    hex = hex.replace('#', '');
    
    // Handle partial hex codes by padding with zeros
    if (hex.length === 3) {
      // Convert 3-digit hex to 6-digit (e.g., f0a -> ff00aa)
      hex = hex.split('').map(char => char + char).join('');
    } else if (hex.length < 6) {
      // Pad with zeros if less than 6 characters
      hex = hex.padEnd(6, '0');
    } else if (hex.length > 6) {
      // Truncate if more than 6 characters
      hex = hex.substring(0, 6);
    }
    
    // Parse the hex values
    const r = parseInt(hex.substr(0, 2), 16);
    const g = parseInt(hex.substr(2, 2), 16);
    const b = parseInt(hex.substr(4, 2), 16);
    
    // Check if parsing was successful
    if (isNaN(r) || isNaN(g) || isNaN(b)) {
      return `rgba(0, 0, 0, ${alpha})`;
    }
    
    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
  }
  
  // Helper function to convert color names to hex
  function colorNameToHex(colorName) {
    const colors = {
      'red': '#ff0000',
      'blue': '#0064ff',
      'green': '#00ff00',
      'yellow': '#ffff00',
      'purple': '#800080',
      'orange': '#ffa500',
      'pink': '#ffc0cb',
      'cyan': '#00ffff'
    };
    return colors[colorName] || '#0064ff';
  }
  
  // Helper function to get icon SVG
  function getIconSvg(iconType) {
    const icons = {
      'plus': '<path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/>',
      'check': '<path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/>',
      'star': '<path d="M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"/>',
      'info': '<path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z"/>',
      'question': '<path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 17h-2v-2h2v2zm2.07-7.75l-.9.92C13.45 12.9 13 13.5 13 15h-2v-.5c0-1.1.45-2.1 1.17-2.83l1.24-1.26c.37-.36.59-.86.59-1.41 0-1.1-.9-2-2-2s-2 .9-2 2H8c0-2.21 1.79-4 4-4s4 1.79 4 4c0 .88-.36 1.68-.93 2.25z"/>',
      'exclamation': '<path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"/>',
      'heart': '<path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/>',
      'circle': '<circle cx="12" cy="12" r="10"/>'
    };
    return icons[iconType] || icons['plus'];
  }
  
  // Close popups when clicking outside
  document.addEventListener('click', function(e) {
    // Only close popups in view mode
    if (currentMode !== 'view') return;
    
    // Check if click is outside hotspots and popups
    if (!e.target.closest('.hotspot') && !e.target.closest('.popup')) {
      document.querySelectorAll('.popup').forEach(popup => {
        popup.style.display = 'none';
      });
    }
  });
</script>

</body>
</html>
